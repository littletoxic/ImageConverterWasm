@using ImageConverter.Services
@using SixLabors.ImageSharp.Formats
@using SixLabors.ImageSharp.Formats.Png
@implements IAsyncDisposable
@inject IJSRuntime JS
@inject ILogger<ImageConversionCard> Logger

<MudGrid Class="mt-4">
    <MudItem xs="12" md="7">
        <MudPaper Class="pa-4" Elevation="2">
            <MudText Typo="Typo.h6" GutterBottom="true">图像预览</MudText>

            <div style="@(_job is { IsLoaded: true } ? "" : "display:none")">
                <MudStack Spacing="1" Class="mb-3">
                    <MudText Typo="Typo.body2"><b>文件名：</b>@_job?.FileName</MudText>
                    <MudText Typo="Typo.body2"><b>原始格式：</b>@_job?.SourceFormat</MudText>
                    <MudText Typo="Typo.body2"><b>尺寸：</b>@(_job?.Width)x@(_job?.Height) px</MudText>
                    <MudText Typo="Typo.body2"><b>文件大小：</b>@ImageFormatInfo.FormatFileSize(_job?.FileSize ?? 0)</MudText>
                    <MudText Typo="Typo.body2"><b>像素内存：</b>@ImageFormatInfo.FormatFileSize((long)(_job?.Width ?? 0) * (_job?.Height ?? 0) * 4)</MudText>
                </MudStack>
            </div>

            <img @ref="_previewImageElem" alt="预览" class="image-preview" />
        </MudPaper>
    </MudItem>

    <MudItem xs="12" md="5">
        <MudPaper Class="pa-4" Elevation="2">
            <MudText Typo="Typo.h6" GutterBottom="true">转换设置</MudText>

            <MudSelect T="IImageFormat"
                       Label="目标格式"
                       Value="_targetFormat"
                       ValueChanged="OnTargetFormatChanged"
                       Variant="Variant.Outlined"
                       Class="mb-4">
                @foreach (var format in ImageFormatInfo.EncodableFormats)
                {
                    <MudSelectItem Value="@format">@format.Name</MudSelectItem>
                }
            </MudSelect>

            @{
                var componentType = EncoderOptionsBase.GetComponentType(_targetFormat);
            }
            @if (componentType is not null)
            {
                <DynamicComponent Type="componentType" Parameters="_encoderOptionsParams"
                                  @ref="_dynamicComponent" />
            }

            @if (_job is { IsLoaded: true } && (long)_job.Width * _job.Height > 20_000_000)
            {
                <MudAlert Severity="Severity.Warning" Class="mt-4" Dense="true">
                    图像像素量较大（@ImageFormatInfo.FormatPixelCount((long)_job.Width * _job.Height)），转换时预计需要 @ImageFormatInfo.FormatFileSize(_estimatedMemory) 内存，可能导致浏览器内存不足。
                </MudAlert>
            }

            <MudButton Variant="Variant.Filled"
                       Color="MudBlazor.Color.Primary"
                       FullWidth="true"
                       Size="MudBlazor.Size.Large"
                       StartIcon="@Icons.Material.Filled.Transform"
                       OnClick="ConvertImage"
                       Disabled="@(_job is not { IsLoaded: true } || _converting)">
                @if (_converting)
                {
                    <MudProgressCircular Size="MudBlazor.Size.Small" Indeterminate="true" Class="mr-2" />
                    <span>转换中...</span>
                }
                else
                {
                    <span>转换</span>
                }
            </MudButton>

            <MudButton Variant="Variant.Outlined"
                       Color="MudBlazor.Color.Primary"
                       FullWidth="true"
                       Size="MudBlazor.Size.Large"
                       StartIcon="@Icons.Material.Filled.Download"
                       OnClick="DownloadResult"
                       Disabled="@(_result is null)"
                       Class="mt-2">
                下载
            </MudButton>

            @if (_convertedSize > 0)
            {
                <MudAlert Severity="Severity.Success" Class="mt-4">
                    转换完成！输出大小：@ImageFormatInfo.FormatFileSize(_convertedSize)
                </MudAlert>
            }

            @if (!string.IsNullOrEmpty(_errorMessage))
            {
                <MudAlert Severity="Severity.Error" Class="mt-4">
                    @_errorMessage
                </MudAlert>
            }
        </MudPaper>
    </MudItem>
</MudGrid>

@code {
    [Parameter, EditorRequired] public IBrowserFile File { get; set; } = default!;

    private IImageFormat _targetFormat = ImageFormatInfo.EncodableFormats.FirstOrDefault(f => f is PngFormat)
                                        ?? ImageFormatInfo.EncodableFormats[0];
    private ImageConversionJob? _job;
    private ConversionResult? _result;
    private bool _converting;
    private long _convertedSize;
    private long _estimatedMemory;
    private string? _errorMessage;
    private ElementReference _previewImageElem;
    private IJSObjectReference? _jsModule;
    private DynamicComponent? _dynamicComponent;
    private Dictionary<string, object>? _encoderOptionsParams;

    private EncoderOptionsBase? EncoderOptions =>
        _dynamicComponent?.Instance as EncoderOptionsBase;

    private void OnTargetFormatChanged(IImageFormat format)
    {
        _targetFormat = format;
        if (_job is not null)
            _job.TargetFormat = format;
        _result?.Stream.Dispose();
        _result = null;
        _convertedSize = 0;
        _estimatedMemory = _job?.EstimateMemory(EncoderOptions) ?? 0;
    }

    private void RecalculateMemory()
    {
        _result?.Stream.Dispose();
        _result = null;
        _convertedSize = 0;
        _estimatedMemory = _job?.EstimateMemory(EncoderOptions) ?? 0;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _jsModule = await JS.InvokeAsync<IJSObjectReference>(
                "import", "./Components/ImageConversionCard.razor.js");
            _encoderOptionsParams = new Dictionary<string, object>
            {
                [nameof(EncoderOptionsBase.OptionsChanged)] = EventCallback.Factory.Create(this, RecalculateMemory),
            };

            await LoadFileAsync();
        }
    }

    private async Task LoadFileAsync()
    {
        _errorMessage = null;
        _convertedSize = 0;

        Logger.LogInformation("开始加载图像");

        try
        {
            const long maxSize = 50 * 1024 * 1024;

            _job?.Dispose();
            _job = new ImageConversionJob(File.Name, File.Size, _targetFormat);
            StateHasChanged();

            if (_jsModule is not null)
            {
                await using var previewStream = File.OpenReadStream(maxSize);
                using var streamRef = new DotNetStreamReference(previewStream);
                await _jsModule.InvokeVoidAsync("previewImage", _previewImageElem, streamRef);
            }

            await using var stream = File.OpenReadStream(maxSize);
            await _job.LoadAsync(stream);
            _estimatedMemory = _job.EstimateMemory(EncoderOptions);
        }
        catch (Exception ex)
        {
            _errorMessage = $"加载图像失败：{ex.Message}";
            _job?.Dispose();
            _job = null;
            Logger.LogError(ex, ex.Message);
        }

        Logger.LogInformation("图像加载完成");

        StateHasChanged();
    }

    private async Task ConvertImage()
    {
        if (_job is not { IsLoaded: true })
            return;

        _converting = true;
        _errorMessage = null;
        _convertedSize = 0;
        _result?.Stream.Dispose();
        _result = null;
        StateHasChanged();

        Logger.LogInformation("开始转换图像");

        try
        {
            var result = await _job.ConvertAsync(EncoderOptions);
            _result = result;
            _convertedSize = result.Size;
        }
        catch (OutOfMemoryException)
        {
            _errorMessage = $"内存不足：图像像素量过大（{ImageFormatInfo.FormatPixelCount((long)_job.Width * _job.Height)}像素），浏览器无法分配足够内存完成转换。请尝试使用较小的图像。";
            Logger.LogError("OutOfMemoryException during conversion: {Width}x{Height}", _job.Width, _job.Height);
        }
        catch (Exception ex)
        {
            _errorMessage = $"转换失败：{ex.Message}";
            Logger.LogError(ex, ex.Message);
        }
        finally
        {
            _converting = false;
            StateHasChanged();
        }
    }

    private async Task DownloadResult()
    {
        if (_result is null || _jsModule is null)
            return;

        _result.Stream.Position = 0;
        using var streamRef = new DotNetStreamReference(_result.Stream, leaveOpen: true);
        await _jsModule.InvokeVoidAsync("downloadFileFromStream", _result.OutputFileName, streamRef);
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        _result?.Stream.Dispose();
        _job?.Dispose();

        if (_jsModule is not null)
        {
            await _jsModule.DisposeAsync();
        }
    }
}
